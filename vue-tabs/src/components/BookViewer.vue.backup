<template>
  <div class="book-viewer" ref="bookViewerRef" :class="{ 'split-pane-active': isSplitPaneEnabled }">
    <div class="split-pane-container">
      <div class="top-pane" :style="{ height: isSplitPaneEnabled ? topPaneHeight + '%' : '100%' }">
        <div v-if="isLoading" class="pane-loading">
          <div class="loading-icon">
            <svg width="32" height="32" viewBox="0 0 48 48" fill="none">
              <path d="M12 8C12 7.44772 12.4477 7 13 7H23C23.5523 7 24 7.44772 24 8V40C24 40.5523 23.5523 41 23 41H13C12.4477 41 12 40.5523 12 40V8Z" stroke="currentColor" stroke-width="2.5" class="book-left"/>
              <path d="M24 8C24 7.44772 24.4477 7 25 7H35C35.5523 7 36 7.44772 36 8V40C36 40.5523 35.5523 41 35 41H25C24.4477 41 24 40.5523 24 40V8Z" stroke="currentColor" stroke-width="2.5" class="book-right"/>
            </svg>
          </div>
          <div class="loading-text">טוען ספר</div>
        </div>
        <!-- Content container must always exist in DOM for C# to add lines -->
        <div class="content-container" :data-tab-id="tabId" :class="{ hidden: isLoading }"></div>
      </div>
      <template v-if="isSplitPaneEnabled">
        <div class="resize-handle" @mousedown="startResize" @touchstart="startResize">
          <div class="resize-handle-bar"></div>
        </div>
        <div class="bottom-pane" :style="{ height: bottomPaneHeight + '%' }">
          <!-- Commentary title bar -->
          <div class="commentary-header">
            <div class="commentary-title">קשרים</div>
            <div v-if="linkGroups.length > 0" class="commentary-navigation">
              <button 
                class="nav-btn" 
                @click="previousGroup" 
                :disabled="currentGroupIndex === 0"
                title="קבוצה קודמת"
              >
                ❮
              </button>
              <select 
                v-model="currentGroupIndex" 
                class="group-selector"
                @change="onGroupChange"
              >
                <option 
                  v-for="(group, index) in linkGroups" 
                  :key="index" 
                  :value="index"
                >
                  {{ group.groupName }}
                </option>
              </select>
              <button 
                class="nav-btn" 
                @click="nextGroup" 
                :disabled="currentGroupIndex === linkGroups.length - 1"
                title="קבוצה הבאה"
              >
                ❯
              </button>
            </div>
          </div>
          
          <!-- Commentary content -->
          <div class="commentary-content" ref="commentaryContentRef">
            <div v-if="isLoadingLinks" class="commentary-loading">
              <div class="loading-spinner"></div>
              <div>טוען קשרים...</div>
            </div>
            <div v-else-if="linkGroups.length === 0" class="commentary-placeholder">
              <div class="placeholder-icon">
                <svg width="48" height="48" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                  <path d="M3 3h18v8H3V3zm0 10h18v8H3v-8z" stroke="currentColor" stroke-width="1.5" fill="none"/>
                </svg>
              </div>
              <div class="placeholder-text">בחר שורה לצפייה בקשרים</div>
            </div>
            <div v-else class="commentary-links">
              <!-- Show ALL groups, not just current one -->
              <div 
                v-for="(group, groupIndex) in linkGroups" 
                :key="groupIndex"
                class="commentary-group"
                :ref="el => setGroupRef(el, groupIndex)"
              >
                <h3 class="group-header">{{ group.groupName }}</h3>
                <div 
                  v-for="(link, linkIndex) in group.links" 
                  :key="linkIndex" 
                  class="link-item"
                  v-html="link.html"
                ></div>
              </div>
            </div>
          </div>
        </div>
      </template>
    </div>
  </div>
</template>

<script setup lang="ts">
import { onMounted, onUnmounted, onActivated, ref, computed, watch, type ComponentPublicInstance } from 'vue'
import { useTabsStore } from '../stores/tabs'

const props = defineProps<{
  tabId: string
}>()

const tabsStore = useTabsStore()
const bookViewerRef = ref<HTMLElement | null>(null)
const contentContainer = ref<HTMLElement | null>(null)
const lineCounter = ref(0)
const initLineIndex = ref(0)
const savedScrollPosition = ref(0)
const isLoading = ref(true)

// Split pane state
const isSplitPaneEnabled = ref(false)
const topPaneHeight = ref(40) // Default 40% for top pane
const bottomPaneHeight = ref(60) // Default 60% for bottom pane
const isResizing = ref(false)

// Commentary/Links state
const selectedLineId = ref<number | null>(null)
const linkGroups = ref<Array<{ groupName: string; links: Array<{ text: string; html: string }> }>>([])
const currentGroupIndex = ref(0)
const isLoadingLinks = ref(false)
const commentaryContentRef = ref<HTMLElement | null>(null)
const groupRefs = ref<Map<number, HTMLElement>>(new Map())

// Expose functions to C# with tab-specific keys
declare global {
  interface Window {
    addLine: (tabId: string, html: string) => void
    addLines: (tabId: string, linesArray: Array<{ id: number; html: string }>) => void
    setInitLineIndex: (tabId: string, index: number) => void
    clearBookContent: (tabId: string) => void
    bookLoadComplete: (tabId: string) => void
  }
}

// Global registry for tab handlers
const tabHandlers = (window as any).__tabHandlers || ((window as any).__tabHandlers = new Map())

// Initialize global functions if not already set
if (!window.addLine) {
  window.addLine = (tabId: string, html: string) => {
    const handler = tabHandlers.get(tabId)
    if (handler?.addLine) handler.addLine(html)
  }
  window.addLines = (tabId: string, linesArray: Array<{ id: number; html: string }>) => {
    const handler = tabHandlers.get(tabId)
    if (handler?.addLines) handler.addLines(linesArray)
  }
  window.setInitLineIndex = (tabId: string, index: number) => {
    const handler = tabHandlers.get(tabId)
    if (handler?.setInitLineIndex) handler.setInitLineIndex(index)
  }
  window.clearBookContent = (tabId: string) => {
    const handler = tabHandlers.get(tabId)
    if (handler?.clearBookContent) handler.clearBookContent()
  }
  window.bookLoadComplete = (tabId: string) => {
    const handler = tabHandlers.get(tabId)
    if (handler?.bookLoadComplete) handler.bookLoadComplete()
  }
}

// Local functions that handle this specific tab
const addLineToThisTab = (html: string) => {
  if (!contentContainer.value) return
  
  const lineElement = document.createElement('line')
  lineElement.tabIndex = 0
  lineElement.innerHTML = html
  contentContainer.value.appendChild(lineElement)
  
  // Check if this is the target line
  const isTargetLine = lineCounter.value === initLineIndex.value
  
  // Only hide loading if:
  // 1. No target line was specified (initLineIndex is 0), OR
  // 2. This is the target line
  if (initLineIndex.value === 0 || isTargetLine) {
    if (isLoading.value) {
      isLoading.value = false
      console.log('BookViewer: Hiding loading - target line loaded or no target specified')
    }
  }
  
  if (isTargetLine) {
    lineElement.scrollIntoView({ behavior: 'auto', block: 'center' })
  }
  
  lineCounter.value++
}

const addLinesToThisTab = (linesArray: Array<{ id: number; html: string }>) => {
  if (!contentContainer.value) return
  
  // C# already sends lines in chunks, so we can process the entire batch at once
  const fragment = document.createDocumentFragment()
  let targetLineElement: HTMLElement | null = null
  let foundTargetLine = false
  
  linesArray.forEach(({ id, html }) => {
    const lineElement = document.createElement('line') as HTMLElement
    lineElement.tabIndex = 0
    lineElement.id = `line-${id}`
    lineElement.innerHTML = html
    fragment.appendChild(lineElement)
    
    // Check if this is the line we want to scroll to
    if (initLineIndex.value > 0 && id === initLineIndex.value) {
      targetLineElement = lineElement
      foundTargetLine = true
      console.log('BookViewer: Found target line', id)
    }
  })
  
  contentContainer.value.appendChild(fragment)
  
  // Only hide loading if:
  // 1. No target line was specified (initLineIndex is 0), OR
  // 2. Target line was found in this batch
  if (initLineIndex.value === 0 || foundTargetLine) {
    if (isLoading.value) {
      isLoading.value = false
      console.log('BookViewer: Hiding loading - target line loaded or no target specified')
    }
  }
  
  // Scroll to target line after appending
  if (targetLineElement) {
    console.log('BookViewer: Scrolling to line', initLineIndex.value)
    const elementToScroll = targetLineElement as HTMLElement
    setTimeout(() => {
      elementToScroll.scrollIntoView({ behavior: 'auto', block: 'center' })
    }, 100)
  }
}

const setInitLineIndexForThisTab = (index: number) => {
  initLineIndex.value = index
}

const clearContentForThisTab = () => {
  if (contentContainer.value) {
    contentContainer.value.innerHTML = ''
    lineCounter.value = 0
  }
}

// No need for any diacritics restoration logic in BookViewer
// The DOM is preserved by KeepAlive, and filters are only applied when user clicks the button

// Split pane resize handlers
const startResize = (e: MouseEvent | TouchEvent) => {
  isResizing.value = true
  e.preventDefault()
  
  const moveHandler = (moveEvent: MouseEvent | TouchEvent) => {
    if (!isResizing.value || !bookViewerRef.value) return
    
    const clientY = 'touches' in moveEvent ? moveEvent.touches[0]?.clientY : moveEvent.clientY
    if (clientY === undefined) return
    
    const rect = bookViewerRef.value.getBoundingClientRect()
    const relativeY = clientY - rect.top
    const percentage = (relativeY / rect.height) * 100
    
    // Constrain between 20% and 80%
    const constrainedPercentage = Math.max(20, Math.min(80, percentage))
    topPaneHeight.value = constrainedPercentage
    bottomPaneHeight.value = 100 - constrainedPercentage
  }
  
  const stopResize = () => {
    isResizing.value = false
    document.removeEventListener('mousemove', moveHandler)
    document.removeEventListener('mouseup', stopResize)
    document.removeEventListener('touchmove', moveHandler)
    document.removeEventListener('touchend', stopResize)
  }
  
  document.addEventListener('mousemove', moveHandler)
  document.addEventListener('mouseup', stopResize)
  document.addEventListener('touchmove', moveHandler)
  document.addEventListener('touchend', stopResize)
}

// Listen for split pane toggle events
const handleSplitPaneToggle = (event: CustomEvent) => {
  if (event.detail.tabId === props.tabId) {
    isSplitPaneEnabled.value = event.detail.enabled
    
    // Clear selection when split pane is disabled
    if (!event.detail.enabled && selectedLineId.value !== null) {
      const selectedLine = document.getElementById(`line-${selectedLineId.value}`)
      if (selectedLine) {
        selectedLine.classList.remove('selected')
      }
      selectedLineId.value = null
      linkGroups.value = []
    }
  }
}

// Set group ref for scrolling
// Set group ref for scrolling
const setGroupRef = (el: Element | ComponentPublicInstance | null, index: number) => {
  if (el && el instanceof HTMLElement) {
    groupRefs.value.set(index, el)
  }
}

// Navigation functions - scroll to group
const previousGroup = () => {
  if (currentGroupIndex.value > 0) {
    currentGroupIndex.value--
    scrollToGroup(currentGroupIndex.value)
  }
}

const nextGroup = () => {
  if (currentGroupIndex.value < linkGroups.value.length - 1) {
    currentGroupIndex.value++
    scrollToGroup(currentGroupIndex.value)
  }
}

const onGroupChange = () => {
  // Group changed via dropdown, scroll to that group
  scrollToGroup(currentGroupIndex.value)
}

const scrollToGroup = (index: number) => {
  const groupElement = groupRefs.value.get(index)
  if (groupElement && commentaryContentRef.value) {
    // Temporarily disable scroll listener to prevent feedback loop
    commentaryContentRef.value.removeEventListener('scroll', handleCommentaryScroll)
    
    groupElement.scrollIntoView({ behavior: 'smooth', block: 'start' })
    
    // Re-enable scroll listener after animation
    setTimeout(() => {
      if (commentaryContentRef.value) {
        commentaryContentRef.value.addEventListener('scroll', handleCommentaryScroll)
      }
    }, 500)
  }
}

// Handle commentary scroll to update dropdown
const handleCommentaryScroll = () => {
  if (!commentaryContentRef.value || linkGroups.value.length === 0 || groupRefs.value.size === 0) return
  
  const containerRect = commentaryContentRef.value.getBoundingClientRect()
  const containerTop = containerRect.top + 50 // Add offset for better detection
  
  let activeIndex = 0
  
  // Find the first group header that is visible or just passed
  groupRefs.value.forEach((groupElement, index) => {
    const headerRect = groupElement.getBoundingClientRect()
    
    // If header is above or at the detection point, it's the active one
    if (headerRect.top <= containerTop) {
      activeIndex = index
    }
  })
  
  // Update dropdown without triggering scroll
  if (currentGroupIndex.value !== activeIndex) {
    currentGroupIndex.value = activeIndex
  }
}

// Handle line click to load links
const handleLineClick = (event: Event) => {
  // Only handle if split pane is enabled
  if (!isSplitPaneEnabled.value) return
  
  const target = event.target as HTMLElement
  const lineElement = target.closest('line')
  
  if (!lineElement || !lineElement.id) return
  
  // Extract line ID from element id (format: "line-123")
  const lineIdMatch = lineElement.id.match(/line-(\d+)/)
  if (!lineIdMatch || !lineIdMatch[1]) return
  
  const lineId = parseInt(lineIdMatch[1])
  
  // Toggle if same line is clicked again
  if (selectedLineId.value === lineId) {
    selectedLineId.value = null
    linkGroups.value = []
    return
  }
  
  // Remove selected class from previous line
  if (selectedLineId.value !== null) {
    const prevLine = document.getElementById(`line-${selectedLineId.value}`)
    if (prevLine) {
      prevLine.classList.remove('selected')
    }
  }
  
  // Add selected class to new line
  lineElement.classList.add('selected')
  selectedLineId.value = lineId
  
  // Request links from C#
  requestLinks(lineId)
}

// Request links from C#
const requestLinks = (lineId: number) => {
  const tab = tabsStore.tabs.find(t => t.id === props.tabId)
  if (!tab || tab.type !== 'book' || !tab.bookId) return
  
  isLoadingLinks.value = true
  linkGroups.value = []
  currentGroupIndex.value = 0
  
  if (window.chrome?.webview) {
    window.chrome.webview.postMessage({
      command: 'GetLinks',
      args: [tab.bookId, lineId, props.tabId]
    })
  }
}

// Expose function to C# to receive links
declare global {
  interface Window {
    setLinks: (tabId: string, groups: Array<{ groupName: string; links: Array<{ text: string; html: string }> }>) => void
  }
}

// Initialize setLinks function
if (!window.setLinks) {
  window.setLinks = (tabId: string, groups: Array<{ groupName: string; links: Array<{ text: string; html: string }> }>) => {
    // Find the BookViewer instance for this tab
    const handler = tabHandlers.get(tabId)
    if (handler?.setLinks) {
      handler.setLinks(groups)
    }
  }
}

// Local function to handle links for this tab
const setLinksForThisTab = (groups: Array<{ groupName: string; links: Array<{ text: string; html: string }> }>) => {
  linkGroups.value = groups
  currentGroupIndex.value = 0
  isLoadingLinks.value = false
}

onMounted(() => {
  contentContainer.value = document.querySelector(`.content-container[data-tab-id="${props.tabId}"]`)
  
  // Listen for split pane toggle
  window.addEventListener('toggleSplitPane', handleSplitPaneToggle as EventListener)
  
  // Clear any existing handlers for this tab to prevent duplicates
  if (tabHandlers.has(props.tabId)) {
    tabHandlers.delete(props.tabId)
  }
  
  // Register this tab's handlers
  tabHandlers.set(props.tabId, {
    addLine: addLineToThisTab,
    addLines: addLinesToThisTab,
    setInitLineIndex: setInitLineIndexForThisTab,
    clearBookContent: clearContentForThisTab,
    setLinks: setLinksForThisTab,
    bookLoadComplete: () => {
      // Book finished loading, restore scroll position
      if (savedScrollPosition.value > 0 && bookViewerRef.value) {
        bookViewerRef.value.scrollTop = savedScrollPosition.value
      }
      
      // Apply divine name censoring if enabled
      if ((window as any).applyCensoringIfEnabled) {
        (window as any).applyCensoringIfEnabled()
      }
    }
  })
  
  // Load saved scroll position from store
  const tab = tabsStore.tabs.find(t => t.id === props.tabId)
  
  // Check if there's an initial line index to scroll to
  if (tab?.initialLineIndex !== undefined) {
    initLineIndex.value = tab.initialLineIndex
    console.log('BookViewer: Setting initial line index to', initLineIndex.value)
    
    // If content already exists, check if target line is loaded
    if (contentContainer.value && contentContainer.value.children.length > 0) {
      const lineElement = contentContainer.value.querySelector(`#line-${tab.initialLineIndex}`) as HTMLElement
      if (lineElement) {
        console.log('BookViewer: Target line already exists, scrolling to line', tab.initialLineIndex)
        lineElement.scrollIntoView({ behavior: 'auto', block: 'center' })
        // Target line exists, hide loading
        isLoading.value = false
      } else {
        console.log('BookViewer: Target line not loaded yet, keeping loading state visible')
        // Target line doesn't exist yet, keep loading visible
        isLoading.value = true
      }
    }
    
    // Clear the initial line index after using it
    tab.initialLineIndex = undefined
    tabsStore.saveTabs()
  } else if (tab?.scrollPosition !== undefined) {
    // No target line, just restore scroll position
    savedScrollPosition.value = tab.scrollPosition
    // Restore scroll position immediately if already has content
    if (bookViewerRef.value && contentContainer.value && contentContainer.value.children.length > 0) {
      bookViewerRef.value.scrollTop = savedScrollPosition.value
      // Content already exists, hide loading
      isLoading.value = false
    }
  } else if (contentContainer.value && contentContainer.value.children.length > 0) {
    // Content exists but no scroll position or target line, just hide loading
    isLoading.value = false
  }
  
  // Request book content if container is empty
  if (tab?.type === 'book' && tab.bookId && contentContainer.value?.children.length === 0) {
    if (window.chrome?.webview) {
      window.chrome.webview.postMessage({
        command: 'OpenBook',
        args: [tab.bookId, props.tabId]
      })
    }
  }
  
  // Save scroll position on scroll
  if (bookViewerRef.value) {
    bookViewerRef.value.addEventListener('scroll', () => {
      if (bookViewerRef.value) {
        savedScrollPosition.value = bookViewerRef.value.scrollTop
        tabsStore.saveScrollPosition(props.tabId, savedScrollPosition.value)
      }
    })
  }
  
  // Add click listener to content container for line clicks
  if (contentContainer.value) {
    contentContainer.value.addEventListener('click', handleLineClick)
  }
})

// Watch for commentary content ref to become available and attach scroll listener
watch(commentaryContentRef, (newVal, oldVal) => {
  if (oldVal) {
    oldVal.removeEventListener('scroll', handleCommentaryScroll)
  }
  if (newVal) {
    newVal.addEventListener('scroll', handleCommentaryScroll)
  }
})

// Restore scroll position when component is reactivated from cache
onActivated(() => {
  // Restore scroll position synchronously - no animation
  if (bookViewerRef.value && savedScrollPosition.value > 0) {
    // Set scroll immediately without any delay
    bookViewerRef.value.scrollTop = savedScrollPosition.value
  }
  // Don't reapply diacritics filter - the DOM content is already in the correct state
  // The KeepAlive preserves the DOM exactly as it was, including filtered text
})

onUnmounted(() => {
  // Save final scroll position
  if (bookViewerRef.value) {
    tabsStore.saveScrollPosition(props.tabId, bookViewerRef.value.scrollTop)
  }
  // Clean up handlers
  tabHandlers.delete(props.tabId)
  // Remove split pane listener
  window.removeEventListener('toggleSplitPane', handleSplitPaneToggle as EventListener)
  // Remove line click listener
  if (contentContainer.value) {
    contentContainer.value.removeEventListener('click', handleLineClick)
  }
  // Commentary scroll listener is cleaned up by the watcher
})
</script>

<style scoped>
.book-viewer {
  height: 100%;
  width: 100%;
  direction: rtl;
  position: relative;
  overflow-y: auto;
}

/* When split pane is active, disable scroll on book-viewer */
.book-viewer.split-pane-active {
  overflow: hidden;
}

.loading-container {
  display: flex;
  align-items: center;
  justify-content: center;
  height: 100%;
  width: 100%;
  background: var(--bg-primary);
}

.loading-content {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 16px;
  animation: fadeIn 0.3s ease-in;
}

@keyframes fadeIn {
  from {
    opacity: 0;
    transform: translateY(-10px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

.loading-icon {
  color: var(--accent-color);
  animation: pulse 2s ease-in-out infinite;
}

@keyframes pulse {
  0%, 100% {
    opacity: 1;
    transform: scale(1);
  }
  50% {
    opacity: 0.6;
    transform: scale(1.05);
  }
}

.loading-icon .book-left {
  animation: bookOpen 1.5s ease-in-out infinite;
  transform-origin: right center;
}

.loading-icon .book-right {
  animation: bookOpen 1.5s ease-in-out infinite;
  animation-delay: 0.1s;
  transform-origin: left center;
}

@keyframes bookOpen {
  0%, 100% {
    opacity: 1;
  }
  50% {
    opacity: 0.4;
  }
}

.loading-text {
  font-size: 18px;
  font-weight: 600;
  color: var(--text-primary);
  font-family: 'Segoe UI Variable', 'Segoe UI', system-ui, sans-serif;
  direction: rtl;
}

.loading-dots {
  display: flex;
  gap: 6px;
  align-items: center;
  height: 8px;
}

.loading-dots span {
  width: 8px;
  height: 8px;
  border-radius: 50%;
  background: var(--accent-color);
  animation: bounce 1.4s ease-in-out infinite;
}

.loading-dots span:nth-child(1) {
  animation-delay: 0s;
}

.loading-dots span:nth-child(2) {
  animation-delay: 0.2s;
}

.loading-dots span:nth-child(3) {
  animation-delay: 0.4s;
}

@keyframes bounce {
  0%, 80%, 100% {
    transform: scale(0.8);
    opacity: 0.5;
  }
  40% {
    transform: scale(1.2);
    opacity: 1;
  }
}

.content-container {
  color: var(--text-primary);
  text-align: justify;
  font-family: var(--text-font);
  padding: 16px;
  font-size: 100%; /* Default, will be overridden by settings */
  user-select: text !important;
  -webkit-user-select: text !important;
  -moz-user-select: text !important;
  -ms-user-select: text !important;
}

.content-container :deep(*) {
  user-select: text !important;
  -webkit-user-select: text !important;
  -moz-user-select: text !important;
  -ms-user-select: text !important;
}

.content-container.hidden {
  display: none;
}

/* Split pane styles */
.split-pane-container {
  display: flex;
  flex-direction: column;
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  width: 100%;
  height: 100%;
}

.top-pane {
  overflow-y: auto;
  direction: rtl;
  position: relative;
  flex-shrink: 0;
}



.top-pane .content-container {
  height: 100%;
}

.resize-handle {
  height: 6px;
  background: var(--bg-secondary);
  border-top: 1px solid rgba(128, 128, 128, 0.15);
  border-bottom: none;
  cursor: ns-resize;
  display: flex;
  align-items: center;
  justify-content: center;
  flex-shrink: 0;
  transition: background 0.2s ease;
  user-select: none;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
}

.resize-handle:hover {
  background: var(--bg-secondary);
}

.resize-handle:active {
  background: var(--hover-bg);
}

.resize-handle-bar {
  width: 40px;
  height: 2px;
  background: rgba(128, 128, 128, 0.2);
  border-radius: 2px;
  transition: all 0.2s ease;
  opacity: 0.5;
}

.resize-handle:hover .resize-handle-bar {
  background: var(--border-color);
  opacity: 0.8;
}

.resize-handle:active .resize-handle-bar {
  background: var(--accent-color);
  opacity: 1;
}

.bottom-pane {
  overflow: hidden;
  direction: rtl;
  position: relative;
  background: var(--bg-primary);
  min-height: 20%;
  display: flex;
  flex-direction: column;
}

.pane-loading {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  height: 100%;
  gap: 12px;
  color: var(--text-secondary);
  font-size: 14px;
  font-family: 'Segoe UI Variable', 'Segoe UI', system-ui, sans-serif;
  direction: rtl;
}

.pane-loading .loading-icon {
  color: var(--accent-color);
  animation: pulse 2s ease-in-out infinite;
}

.pane-loading .loading-icon .book-left {
  animation: bookOpen 1.5s ease-in-out infinite;
  transform-origin: right center;
}

.pane-loading .loading-icon .book-right {
  animation: bookOpen 1.5s ease-in-out infinite;
  animation-delay: 0.1s;
  transform-origin: left center;
}

/* Commentary header */
.commentary-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 8px 12px;
  background: var(--bg-secondary);
  border-bottom: 1px solid var(--border-color);
  direction: rtl;
  flex-shrink: 0;
  min-height: 44px;
}

.commentary-title {
  font-size: 14px;
  font-weight: 600;
  color: var(--text-primary);
}

.commentary-navigation {
  display: flex;
  align-items: center;
  gap: 4px;
  flex-shrink: 1;
  min-width: 0;
}

.nav-btn {
  width: 28px;
  height: 28px;
  background: transparent;
  border: 1px solid var(--border-color);
  border-radius: 4px;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  color: var(--text-primary);
  transition: all 0.2s ease;
  flex-shrink: 0;
}

.nav-btn:hover:not(:disabled) {
  background: var(--hover-bg);
  border-color: var(--accent-color);
}

.nav-btn:disabled {
  opacity: 0.3;
  cursor: not-allowed;
}

.group-selector {
  padding: 4px 8px;
  background: var(--bg-primary);
  border: 1px solid var(--border-color);
  border-radius: 4px;
  color: var(--text-primary);
  font-size: 13px;
  cursor: pointer;
  direction: rtl;
  min-width: 100px;
  max-width: 200px;
  flex: 1;
}

.group-selector:focus {
  outline: none;
  border-color: var(--accent-color);
}

/* Commentary content */
.commentary-content {
  overflow-y: auto;
  flex: 1;
  padding: 16px;
  direction: rtl;
}

.commentary-loading {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  height: 100%;
  gap: 12px;
  color: var(--text-secondary);
}

.loading-spinner {
  width: 24px;
  height: 24px;
  border: 3px solid var(--border-color);
  border-top-color: var(--accent-color);
  border-radius: 50%;
  animation: spin 0.8s linear infinite;
}

@keyframes spin {
  to { transform: rotate(360deg); }
}

.commentary-placeholder {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  height: 100%;
  gap: 16px;
  color: var(--text-secondary);
  opacity: 0.6;
}

.placeholder-icon {
  color: var(--text-secondary);
  opacity: 0.5;
}

.placeholder-text {
  font-size: 16px;
  font-weight: 500;
  font-family: 'Segoe UI Variable', 'Segoe UI', system-ui, sans-serif;
  direction: rtl;
}

.commentary-links {
  display: flex;
  flex-direction: column;
  gap: 48px;
  padding-bottom: 32px;
}

.commentary-group {
  display: flex;
  flex-direction: column;
  gap: 12px;
  padding-bottom: 24px;
  border-bottom: 1px solid var(--border-color);
}

.commentary-group:last-child {
  border-bottom: none;
}

.group-header {
  font-size: 20px;
  font-weight: 500;
  color: var(--text-primary);
  margin: 0 0 16px 0;
  padding: 12px 16px;
  direction: rtl;
  font-family: var(--header-font);
  background: var(--bg-secondary);
  letter-spacing: 0.5px;
  border-radius: 4px;
}

.link-item {
  color: var(--text-primary);
  font-family: var(--text-font);
  line-height: 1.6;
  direction: rtl;
  padding: 8px 0;
  margin: 0;
  text-align: justify;
}

.content-container :deep(line:not(:has(h1, h2, h3, h4, h5, h6))) {
  display: block;
  contain: layout style;
  padding-block-start: 0.3em;
}

/* Header hierarchy styling */
.content-container :deep(line h1),
.content-container :deep(line h2),
.content-container :deep(line h3),
.content-container :deep(line h4),
.content-container :deep(line h5),
.content-container :deep(line h6) {
  font-family: var(--header-font);
  color: var(--text-primary);
  line-height: 1.4;
  margin: 0;
  text-align: right;
}

/* H1 - Main title */
.content-container :deep(line h1) {
  font-size: 2em;
  font-weight: 700;
  padding: 0.8em 0 0.4em 0;
  margin-bottom: 0.5em;
  border-bottom: 1px solid var(--border-color);
  letter-spacing: -0.02em;
}

/* H2 - Major section */
.content-container :deep(line h2) {
  font-size: 1.6em;
  font-weight: 700;
  padding: 0.7em 0 0.3em 0;
  margin-bottom: 0.4em;
  letter-spacing: -0.01em;
}

/* H3 - Subsection */
.content-container :deep(line h3) {
  font-size: 1.4em;
  font-weight: 600;
  padding: 0.6em 0 0.2em 0;
  margin-bottom: 0.3em;
}

/* H4 - Minor heading */
.content-container :deep(line h4) {
  font-size: 1.2em;
  font-weight: 600;
  padding: 0.5em 0 0.2em 0;
  margin-bottom: 0.2em;
  color: var(--text-primary);
  opacity: 0.95;
}

/* H5 - Small heading */
.content-container :deep(line h5) {
  font-size: 1.1em;
  font-weight: 600;
  padding: 0.4em 0 0.15em 0;
  margin-bottom: 0.15em;
  color: var(--text-primary);
  opacity: 0.9;
}

/* H6 - Smallest heading */
.content-container :deep(line h6) {
  font-size: 1em;
  font-weight: 600;
  padding: 0.3em 0 0.1em 0;
  margin-bottom: 0.1em;
  color: var(--text-secondary);
  text-transform: uppercase;
  letter-spacing: 0.05em;
  font-size: 0.9em;
}

/* Hover effects */
.content-container :deep(line:hover) {
  background: var(--hover-bg);
}

.content-container :deep(line:has(h1, h2, h3, h4, h5, h6):hover) {
  background: transparent;
}

.content-container :deep(line:has(h1, h2, h3, h4, h5, h6)) {
  cursor: default;
}

/* Selected line styling - persistent until another line is clicked or toggled */
.content-container :deep(line:not(:has(h1, h2, h3, h4, h5, h6)).selected) {
  border-right: 3px solid var(--accent-color);
  padding-right: 3px;
  margin-right: -3px;
}

/* Keep focus outline disabled */
.content-container :deep(line:focus) {
  outline: none;
}


</style>
